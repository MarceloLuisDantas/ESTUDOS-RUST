# Linguagem Rust
## Resumo
Todos sabemos o quanto Rust esta sendo falada e adotada como alternativa ao C e C++ por ser uma linguagem extremamente eficiente e quase tão rapida quanto (dependendo da situação ate mais), porem sem todas as dificuldades que escrever codigo em C e C++ possui, como gerenciamento de memoria e a dificuldade em manter o codigo estavel. 
No inicio dos anos 90, **Bjarne Stroustrup**, um dos responsaveis pelo C++, disse a famosa frase [*"C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off"*](https://www.stroustrup.com/quotes.html) No seu site pessoal, ele explica que essa frase se aplica a qualquer linguagem que protege o programador de pequenos problemas, poís ao ir o livrando de problemas simples, quando ele se deparar com problemas maiores e mais incomuns, que muitas vezes derivam dos problemas menores, assim tudo se torna mais dificil. 
E com essa ideia em mente podemos começar a entender o porque Rust existe e esta sendo tão agraciada com o titulo de "Linguagem mais amada" pelo Stack Overflow *(sim eu sei que você já esta cansado de let isso em todo lugar que fale de Rust)*

## Onde? Quando? Por que?
Onde? Mozilla (eu sei não surgiu aqui e sim nos porões do Graydon Hoare, mas pra fins praticos vamos assumir que foi). Quando? Por volta de 2009 e em 2010 foi lançada. Por que? Aqui é onde se abre a o livro de contos e fabulas que deu origem ao Rust. 
Quando você pensa em alto desempenho de software hoje em dia, o que vem a sua mente? Na sua eu não sei, porem na minha sempre vem C e C++. C/C++ são categorizados como linguagem de Sistemas, que são linguagens com o minimo de abstrações, onde o programdor tem acesso ao hardware e memoria de forma mais direta. Essas linguagens são feitas na ideia de desenvolver sistemas *(meio obviu pelo titulo)*, sendo assim, elas são feitas para ser o mais rapido e otimizadas possivel, não atoa quando se ve o top de competições de algoritmos, é quase certo que tenha sido usado C/C++.
Porem, C/C++ são famosos por outra coisa alem de serem rapidos, serem dificeis. Pense, se você esta lindado com uma lang sem abstrações fortes, e que você tem toda liberdade para fazer o que quiser, o que vai acontecer? Exatamente, problemas. Linguagens de sistemas possuiem um gerenciamento de memoria manual, o programdor precisa especificar quanto de memoria cada valor vai ocupar na memoria, e quando ele deve ser removido da memoria, afinal quando 	John Carmack estava lidando com um [NeXT PC](https://en.wikipedia.org/wiki/NeXT_Computer) com poderosos 8 MB de Ram, enquanto criava Doom *(que caso você não conheca, como você veio para aqui?)*, cada bit era importante, e cada frame contava. 
Era uma epoca onde a memoria era cara, e processamento limitado, claro, já era 1993, e já se podia programar sem Assembly, porem de longe não se tinha memoria o suficiente para se desperdiçar como hoje em dia. Então linguagens como Java estavam longe de rodar em um PC para algo que exigisse muito do hardware como um jogo. Porem o tempo foi passando, a memoria foi se tornando mais barata e os processadores foram ficando mais potentes, a necessidade de ser do nivel de um John Carmack para programar foi se tornando menos necessario. Porem nunca se perdeu a necessidade de codigo eficiente e rapido, nunca um Java ou Go nunca iriam satisfazer as necessidades de um C ou C++, por um motivo, Garbage Collector. Um Garbage Collector é o que tira a necessidade de se lidar com memoria durante o desenvolvimento, pois em tempo de execução ele faz isso automaticamente, porem isso vem com um custo, um Garbage Collector é lento, ate mesmo os mais eficientes ainda adicionam lentidma e peso a um programa. 
Na maioria dos casos a comodidade de desenvolver sem precisar se preocupar com o gerenciamento de memoria em troca detornar um software um tanto mais lento é totalmente aceitavel, porem existem casos de softwares de alto desempenho que esse tempo e peso extra são valiosos, casos estes desde o seu Navegador Web ate uma Maquina de Eletrocardiograma
Porem C/C++ são linguagens antigas, dos anos 70, e ela foi e é amplamente utilizada em todo o mundo, principalmente em sistemas criticos como grandes data centers e telefonia, sistemas que não podem falhar. Então isso torna C/C++ linguagens lentas, que evoluem muito devagar. O que não é um problema propiamente dito, C/C++ não tem como proposta ser uma linguagem moderna. Porem isso vem com problemas, e é agora que o Rust aparece.
O principal problema de C/C++ é o gerenciamento de memoria, isso esta claro, ponteiros nulos são um perigo, e 2 valores apontando para o mesmo local nem se fala. E atualmente qual um dos principais pontos de foco de palestrantes ruins que nunca nem leram [MM-M](https://www.amazon.com.br/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959) na vida? Exatamente multi-thread (ou qualquer outro conceito da Decada de 80 pintado como novidade).    

<p align="center">
 <img height="600" src="./mt.jpeg" alt="Minha Figura">
</p>
Essa imagem é famosa, uma placa nos escritorios da Mozilla escrito "Must be this tall to write multi-threaded code" O regitro mais antigo que eu pude encontrar foi de 2013 [neste post](https://twitter.com/themitcho/status/308026012455821312). Essa placa é uma piada sobre ser quase humanamente impossivel você escrever um codigo mult-threaded realmente seguro. *(Caso n tenha notado, o super calvo no canto esta em de pé em uma mesa alta)* Que de fato, escrever codigo multi thread em C/C++ ultilizando ponteiros é uma tarefa quase desumana, a quantidade de problemas por um valor ser auterado quando não deveria, ou um valor ser deletado enquanto outra thread esta tentando acessá-lo tornava o desenvolvimento estremamente lento, e se perdia mais tempo arrumando problemas envolvendo memoria do que qualquer outra coisa. 
E foi com as mãos cansadas de tanto resolver problemas de memoria que o funcionario da Mozilla, por volta de 2008~2009 Graydon Hoare descidiu resolver esse problema da forma mais radical possivel, criando uma nova linguagem.

## Rust -game
Querendo resolver o problema de gerenciamento de memoria Graydon Hoare começou a olhar o que se tinha no mundo das linguagens. Ele sabia que um garbage collector convencional não seria a melhor solução pelas motivos já ditos. Enquanto procurava ele encontrou inspiração em no sistema de Regiões de Cyclone e o Garbage Collector de ML *(Vou saber explicar o por que? Não, fica como lição de casa)*
O resultado final de muito estudo e planejamento foi o Borrow Checker, o grande diferencial do Rust, possui um gerenciamento de memorial "automatico" que se baseia em não deixar o programador fazer merda. Borrow Checker vem para resolver o problema de memoria de uma forma muito simples, cada valor tem um dono, e quando o escopo onde este valor esta acaba ele é deletado. O que significa que se vc criar um valor dentro de uma função e passar o ponteiro dela como retorno, vai dar errado, A NÃO SER QUE E UNICAMENTE SE, você especificar na declaração de função o lifetime deste valor. Life time é algo que eu ainda não estudei a fundo, porem é o grande CARALHO do Rust em relação a outras langs, pois é com ele que Rust pode ter um gerenciamento de memoria automatico sem perder muita performance. 
Rust veio para permitir uma segunda opção viavel ao C/C++ quando for necessario alta performace e lidar com multi thread, pois se nem um valor pode ser lido é/ou alterado em 2 lugares diferentes, removendo o problema de condição de corrida do multi thread.